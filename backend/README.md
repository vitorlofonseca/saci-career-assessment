# Saci Backend

> This is the backend module of the Saci project, its purpose is to serve as a comprehensive guide and learning tool for aspiring software engineers.

# Table of Contents

- [General Overview](#general-overview)
- [Architecture](#architecture)
- [Getting Started](#getting-started)
  - [Development Environment Setup](#development-environment-setup)
  - [Installation](#installation)
  - [Run](#run)
- [Run with MySQL database](#run-with-mysql-database)
  - [Run Database](#run-database)
  - [Installation](#installation-mysql)
  - [Run](#run-mysql)
- [How to manage database migrations](#how-to-manage-database-migrations)
  - [How does Flyway work](#how-does-flyway-work)
  - [Update Flyway changes through maven plugin](#update-flyway-changes-through-maven-plugin)
  - [Other possible Flyway properties](#other-possible-flyway-properties)
- [Swagger UI](#swagger-ui)
  - [How to manage it](#how-to-manage-it)
  - [How to document the API resources](#how-to-document-the-api-resources)
  - [Useful properties](#useful-properties)

## General Overview

- Follows a **DDD (Domain-Driven Design)** architecture;
- Programmed in **Java** with the support of **Spring**;
- It's integrated with an embedded database (**H2**) and with a **MySQL** database;
- Uses **Flyway** for automated database migrations and versioning.

## Architecture

> Domain-Driven Design (DDD) is a software development approach that focuses on understanding the business domain and creating
> a software model that reflects it. The goal is to align the software’s structure and language (class names, methods, variables)
> with the business domain. This helps in closing the gap between the business reality and code.

**Example of DDD Structure:**

```
src
└── main
    └── java
        └── saci
            ├── application
            │   └── RoleController.java
            ├── domain
            │   ├── model
            │   │   └── Role.java
            │   └── service
            │       └── RoleService.java
            ├── infrastructure
            │   └── RoleRepository.java
            └── Application.java
```

In this architecture the core domain and it's logic should be the center of attention. The domain layer should be isolated
from both the infrastructure and the application layers, allowing it's logic to be easily tested and evolved independently of the other layers.

- Infrastructure Layer Examples: API's, databases and event sources that the project consumes;
- Application Layer Examples: API's that are consumed by the project or events that trigger its execution;

## Getting Started

### Development Environment Setup

### Installation

```bash
$ mvn clean install
```

### Run

```bash
$ mvn spring-boot:run
```

Default page: http://localhost:8080/api/roles

## Run with MySQL database

### Run Database

```bash
$ docker-compose up -d
```

### Installation (MySQL)

```bash
$ mvn clean install
```

### Run (MySQL)

```bash
$ mvn spring-boot:run -"Dspring-boot.run.profiles"=mysql -Pmysql
```

## How to manage database migrations

Migrations will be done through the usage of the framework **Flyway**, which allows to place schema migration scripts in the
same repository as the code, achieving direct versioning of the scripts alongside the versioning of the application.

### How does Flyway work

Spring will inject automatically into Flyway it's database configuration from the datasource property inside _application.yml_.
With that, when starting the Spring application, Flyway will go, by default, to the package _\*resources/db/migration_ and runs all the sql scripts (_\*.sql_ files) inside it.
If you want to change the package that Flyway loads the files it must be used in the following property inside _application.yml_:

```
spring.flyway.locations: classpath:db/migration/example1,classpath:db/migration/example2
```

The sql files must have the following convention: _V1\_\_Example.sql_

- _V1_: This will specify the version (in this case 1) to Flyway;
  - If there is a small version change to 1.1 it should be _V1_1_
- _Example_: Description of what the script will do;
- \_\_: Separator between version and description.

**Note:** Flyway saves the history of migrations inside a table automatically generated by it, the default name is
_flyway_schema_history_ and contains important information about each migration file, like version, description, script, checksum, date.

### Update Flyway changes through maven plugin

- Validate the migration:
  ```bash
  $ mvn flyway:validate
  ```
- If there is a conflict with another version:
  - Expected:
    - Cleans all history of Flyway table (avoid at all costs in production):
      ```bash
      $ mvn flyway:clean
      ```
      **OR**
    - Delete the conflicting record from the database, for instance for the script **_V1_**\_\_Exmple.sql (version 1):
      ```
      DELETE FROM flyway_schema_history WHERE version = 1;
      ```
  - Unexpected:
    - Ignore the changes and migration isn't done:
      ```bash
      $ mvn flyway:repair
      ```
      **OR**
    - Manually reverting the changed sql file, for example through git.
- If everything is good for the migration, then run the command:
  ```bash
  $ mvn flyway:migrate
  ```
- To check the migration history:
  ```bash
  $ mvn flyway:info
  ```
  **Note:** To be able to use Flyway maven plugin (_mvn flyway_) it is required the access to some configurations (database related)
  which unfortunately can't be automatized through Spring at the moment.
  To abstract those mandatory configurations from the _pom.xml_ it can be used a Flyway configuration file (flyway.conf)
  and the maven Flyway command should be run in the same location as of the configuration file (root of project in this case).

### Other possible Flyway properties

```
spring.flyway.sql-migration-prefix: V
spring.flyway.repeatable-sql-migration-prefix: R
spring.flyway.sql-migration-separator: __
spring.flyway.sql-migration-suffixes: .sql
spring.flyway.schemas: schema1, schema2
```

Disable Flyway execution on the run of the Spring App:

```
spring.flyway.enabled: false
```

## Swagger UI

This is a popular framework used for API documentation and testing, it enables a visualization of the API resources without
having any of the implementation logic in place.

### How to manage it?

Run the application and go to the default swagger ui page:

- http://localhost:8080/swagger-ui.html

Other option is to go to the default JSON format page:

- http://localhost:8080/v3/api-docs

### How to document the API resources?

The documentation is based of the usage of annotations along with descriptions, here are the most impactful ones:

- **@Operation**: has a property called "summary" that is a string that should describe what the endpoint does;
- **@ApiResponses**: has a property called "value" that aggregates a list of @ApiResponse annotations;
- **@ApiResponse**: has 3 main properties that describe the http status returned from the API:
  - "responseCode": the http status returned;
  - "description": description of what happened in that specific http status;
  - "content": what will be returned in that specific http status for the API, through the usage of a @Content annotation;
- **@Content**: has 2 properties to identify what will be returned:
  - "mediaType": describes in what format it will be returned (usually in _application/json_);
  - "array"/"schema": if it is returned a list it must be used the property array (@ArraySchema) otherwise it is used the property schema,
    which contains the annotation @Schema;
- **@ArraySchema**: has a property called "schema" that contains a @Schema annotation, and it's purpose is to show that it
  will be returned a list of objects and not only one;
- **@Schema**: has a property called "implementation" that contains a class to identify the schema format returned by the API.

**Example:**

```
@Operation(summary = "Get all of the objects")
@ApiResponses(
  value = {
    @ApiResponse(
      responseCode = "200",
      description = "List of all objects",
      content = {
        @Content(
          mediaType = "application/json",
          array =
            @ArraySchema(
              schema = @Schema(implementation = Object.class)))
    }),
    @ApiResponse(
      responseCode = "500",
      description = "Internal error while fetching list of objects")
    })
@GetMapping
public ResponseEntity<List<Object>> getObjects() {
  ...
}
```

### Useful properties

To change the default page url change the following application.yml property:

```
springdoc.swagger-ui.path: /<EXAMPLE_URL>.html
```

Same thing for the JSON page:

```
springdoc.api-docs.path: /<EXAMPLE_URL>
```

Sort API paths, in this case through their HTTP methods:

```
springdoc.swagger-ui.operationsSorter: method
```
